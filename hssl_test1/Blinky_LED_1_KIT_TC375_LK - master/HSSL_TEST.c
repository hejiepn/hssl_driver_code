/**********************************************************************************************************************
 * \file HSSL_TEST.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/

#include "HSSL_TEST.h"
#include "HSSL_interrupt.h"
#include "Libraries\iLLD\TC37A\Tricore\Hssl\Hssl\IfxHssl_Hssl.h"
#include "Libraries\iLLD\TC37A\Tricore\_Impl\IfxHssl_cfg.h"
#include "Libraries\iLLD\TC37A\Tricore\Hssl\Std\IfxHssl.h"
#include "Libraries\iLLD\TC37A\Tricore\Port\Std\IfxPort.h"
#include "Libraries\iLLD\TC37A\Tricore\Scu\Std\IfxScuCcu.h"
#include "Libraries\Infra\Sfr\TC37A\_Reg\IfxHsct_reg.h"
#include "Libraries\iLLD\TC37A\Tricore\Dma\Dma\IfxDma_Dma.h"
#include "Libraries\iLLD\TC37A\Tricore\Scu\Std\IfxScuWdt.h"
// #include "SchM_Hssl.h"
#include "stdbool.h"
#include "stdint.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
// used globally test
static IfxHssl_Hssl hssl;
static IfxHssl_Hsct hsct;
int setHighSpeedMode = 0;
int setLoopBack = 0;
IfxHssl_Hssl_Channel hsslChannel[4];
IfxScuCcu_Config IfxScuCcu_sampleClockConfig;
__attribute__((aligned(256))) uint32 txData[80]; // for streaming used

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/

/* This function initializes the HSSL master module */
void initHSSL(char ifMode, char sMode, int loopBackMode) // s = slave mode, m = master mode
{

    /*module initialisation*/

    // create HSCT module config
    /*
       1. func: the default IF mode is set as master, the highspeed mode is off, loopback is off
       and hsctConfig will point to hsct register
       2. func: the new pointer hsctSFR will point to hsct register now, hsctSFr will be added to hsct module handle,
       selected loopback will be added to hsct handle
       */

    IfxHssl_Hsct_Config hsctConfig;
    IfxHssl_Hssl_initHsctModuleConfig(&hsctConfig, &MODULE_HSCT0);

    if (ifMode == 's')
    {
        // select the interface mode (in case of slave)
        hsctConfig.interfaceMode = IfxHssl_InterfaceMode_slave;
    }

    if (ifMode == 'm')
    {
        if (sMode == 'h')
        {
            hsctConfig.highSpeedMode = TRUE;
            setHighSpeedMode = 1;
        }
        if (loopBackMode == 1)
        {
            hsctConfig.loopBack = TRUE;
            setLoopBack = 1;
        }
    }

    // initialize HSCT module
    IfxHssl_Hssl_initHsctModule(&hsct, &hsctConfig);

    if (ifMode == 's')
    {
        IfxScuCcu_initConfig(&IfxScuCcu_sampleClockConfig);
        IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.pllInputClockSelection = IfxScuCcu_PllInputClockSelection_fSysclk;
        IfxScuCcu_init(&IfxScuCcu_sampleClockConfig);
        if (hsct.hsct->IRQ.B.PLER == 0x1 && hsct.hsct->STATPHY.B.PLOCK == 0x1)
        {
            hsct.hsct->IRQ.B.PLER = 0x0;
        }
    }

    // hsct interrupt
   // initHSCTinterrupt();

    // create HSSL module config
    /*
          1. func: hssslConfig pointer points to hssl register, AW start and end addresses will be defined,
          predivider value will be defined
          2. func: hsslSFR pointer points to hssl register, hsslSFR will be added to Hssl module handle,
          hssl module will be enabled with respective function, stream mode will be disabled,
          AW window ranges will be added to hsslSFR, AW read/write rights will be added,
          clear initialize mode flag, setting JTAG_ID, wait in while loop as long MFLAGS.INI
          (Indicates if the module is in the Initialize(1) or Run mode(0)) is true
          */

    IfxHssl_Hssl_Config hsslConfig;
    IfxHssl_Hssl_initHsslModuleConfig(&hsslConfig, &MODULE_HSSL0);

    // initialize HSSL module
    IfxHssl_Hssl_initHsslModule(&hssl, &hsslConfig);

    /*channel initialisation*/
    /*
        1. func: set channelconfig pointer to hsct and hssl registers, set default channel_0_ID,
        per default streaming mode is single, set loopback settings from hsct also for hssl
        2. func. adding hsct and hssl register pointer to channel handle, adding channel id to channel handle,
        set default request: no action, get loopback and streaming mode settings as before setted
        */

    // create HSSL channel config
    IfxHssl_Hssl_ChannelConfig hsslChannelConfig;
    IfxHssl_Hssl_initChannelConfig(&hsslChannelConfig, &hssl, &hsct);

    // initialize the channels
    for (int i = 0; i < 4; ++i)
    {
        hsslChannelConfig.channelId = (IfxHssl_ChannelId)i;
        IfxHssl_Hssl_initChannel(&hsslChannel[i], &hsslChannelConfig);
    }

    // HSSL is ready for use now!
}

/* This function starts a simple data transfer */

void simpleTransferHSSL(int channelNm, uint32 address, uint32 data)
{
    // write some data to remote location:
    IfxHssl_Hssl_write(&hsslChannel[channelNm], address, data, IfxHssl_DataLength_32bit);

    // wait for the acknowledgement
    while (IfxHssl_Hssl_waitAcknowledge(&hsslChannel[channelNm]) != IfxHssl_Hssl_Status_ok)
    {
        if (IfxHssl_Hssl_waitAcknowledge(&hsslChannel[channelNm]) == IfxHssl_Hssl_Status_error)
        {
            IfxHssl_Hssl_checkErrors(&hssl);
            break;
        }
    }
}

/* This function returns the read data */
// pay attention that word space is 32bit and you can only right at the beginning of each word space address 0x7000 0000, 0x7000 0004 ...
void simpleReadHSSL(int channelNm, uint32 address)
{
    // read command

    // read some data from remote location:
    IfxHssl_Hssl_read(&hsslChannel[channelNm], address, IfxHssl_DataLength_32bit);

    // wait for the acknowledgement
    while (IfxHssl_Hssl_waitAcknowledge(&hsslChannel[channelNm]) != IfxHssl_Hssl_Status_ok)
    {
        if (IfxHssl_Hssl_waitAcknowledge(&hsslChannel[channelNm]) == IfxHssl_Hssl_Status_error)
        {
            IfxHssl_Hssl_checkErrors(&hssl);
            break;
        }
    }

    // read data from the register
    uint32 dataL = IfxHssl_Hssl_getReadData(&hsslChannel[channelNm]);
}

/*HSSL driver also supports streaming transfers of data as a memory block at both low and high speeds.*/

void streamingTransfer(int channelNm)
{

    // choose a channel other than channel2 for register access
    // prepare streaming of single memory block

    IfxHssl_Hssl_prepareStream(&hsslChannel[channelNm], 0x70000000, 10);

    // for single block streaming transfer
    // change the txData address to global address before passing it to the API

    // IfxHssl_Hssl_writeStream(&hssl, (uint32 *)IFXCPU_GLB_ADDR_DSPR(IfxCpu_getCoreId(), (uint32)txData),  10);

    IfxHssl_Hssl_writeStream(&hssl, txData, 10);

    // wait until the streaming is finished
    while (IfxHssl_Hssl_waitAcknowledge(&hsslChannel[2]) != IfxHssl_Hssl_Status_ok)
    {
    }
}

void speedMode(char speedMode) // h= highSpeed and l = lowSpeed
{
    if (hsct.hsct->INIT.B.IFM == IfxHssl_InterfaceMode_master)
    {
        switch (speedMode)
        {
        case 'h':
            // Set the Tx link speed of the master to Low speed
            IfxHssl_setHsctTxLinkSpeed(&(*hsct.hsct), IfxHssl_MasterModeTxSpeed_lowSpeed);

            // Enable reception at the Slave
            IfxHssl_Hssl_sendControlCommand(&hsct, IfxHssl_ControlCommand_enableReception);

            // Send interface commmand to change Rx to High speed at the target
            IfxHssl_Hssl_sendControlCommand(&hsct, IfxHssl_ControlCommand_highSpeedReception);

            // Send interface commmand to change Tx to High speed at the target
            IfxHssl_Hssl_sendControlCommand(&hsct, IfxHssl_ControlCommand_highSpeedTransmission);

            // Set the Tx link speed of the master to High speed
            IfxHssl_setHsctTxLinkSpeed(&(*hsct.hsct), IfxHssl_MasterModeTxSpeed_highSpeed);

            // Set the Rx link speed of the master to High speed
            IfxHssl_setHsctRxLinkSpeed(&(*hsct.hsct), IfxHssl_MasterModeRxSpeed_highSpeed);
            break;

        case 'l':
            // Set the Tx link speed of master to Low speed
            IfxHssl_setHsctTxLinkSpeed(&(*hsct.hsct), IfxHssl_MasterModeTxSpeed_lowSpeed);

            // Enable reception at the Slave
            IfxHssl_Hssl_sendControlCommand(&hsct, IfxHssl_ControlCommand_enableReception);

            // Send interface command to change Rx to low speed at the target
            IfxHssl_Hssl_sendControlCommand(&hsct, IfxHssl_ControlCommand_lowSpeedReception);

            // Set the Rx link speed of master to Low speed
            IfxHssl_setHsctRxLinkSpeed(&(*hsct.hsct), IfxHssl_MasterModeRxSpeed_lowSpeed);

            // Send interface command to change Tx to low speed at the target
            IfxHssl_Hssl_sendControlCommand(&hsct, IfxHssl_ControlCommand_lowSpeedTransmission);
            break;

        default: // highspeed mode
            // Set the Tx link speed of the master to Low speed
            IfxHssl_setHsctTxLinkSpeed(&(*hsct.hsct), IfxHssl_MasterModeTxSpeed_lowSpeed);

            // Enable reception at the Slave
            IfxHssl_Hssl_sendControlCommand(&hsct, IfxHssl_ControlCommand_enableReception);

            // Send interface commmand to change Rx to High speed at the target
            IfxHssl_Hssl_sendControlCommand(&hsct, IfxHssl_ControlCommand_highSpeedReception);

            // Send interface commmand to change Tx to High speed at the target
            IfxHssl_Hssl_sendControlCommand(&hsct, IfxHssl_ControlCommand_highSpeedTransmission);

            // Set the Tx link speed of the master to High speed
            IfxHssl_setHsctTxLinkSpeed(&(*hsct.hsct), IfxHssl_MasterModeTxSpeed_highSpeed);

            // Set the Rx link speed of the master to High speed
            IfxHssl_setHsctRxLinkSpeed(&(*hsct.hsct), IfxHssl_MasterModeRxSpeed_highSpeed);
            break;
        }
    }
}

void setSlave(void)
{
    if (setHighSpeedMode == 1)
    {
        IfxHssl_setHsctTxLinkSpeed(&(*hsct.hsct), IfxHssl_MasterModeTxSpeed_lowSpeed);

        IfxHssl_Hssl_sendControlCommand(&hsct, IfxHssl_ControlCommand_enableReception);

        IfxHssl_Hssl_sendControlCommand(&hsct, IfxHssl_ControlCommand_highSpeedClockStart);

        IfxHssl_Hssl_sendControlCommand(&hsct, IfxHssl_ControlCommand_highSpeedReception);

        IfxHssl_Hssl_sendControlCommand(&hsct, IfxHssl_ControlCommand_highSpeedTransmission);

        IfxHssl_setHsctTxLinkSpeed(&(*hsct.hsct), IfxHssl_MasterModeTxSpeed_highSpeed);
    }
    else
    {

        IfxHssl_setHsctTxLinkSpeed(&(*hsct.hsct), IfxHssl_MasterModeTxSpeed_lowSpeed);

        IfxHssl_Hssl_sendControlCommand(&hsct, IfxHssl_ControlCommand_enableReception);

        // IfxHssl_Hssl_sendControlCommand(&hsct, IfxHssl_ControlCommand_highSpeedClockStart);

        IfxHssl_Hssl_sendControlCommand(&hsct, IfxHssl_ControlCommand_lowSpeedReception);

        IfxHssl_Hssl_sendControlCommand(&hsct, IfxHssl_ControlCommand_lowSpeedTransmission);
    }
    if (setLoopBack == 1)
    {
        IfxHssl_Hssl_sendControlCommand(&hsct, IfxHssl_ControlCommand_turnOnPayloadLoopback);
    }
}

void sendPing(void)
{
    IfxHssl_Hssl_sendControlCommand(&hsct, IfxHssl_ControlCommand_ping);
}

void setClockTest(void)
{
    IfxHssl_Hssl_sendControlCommand(&hsct, IfxHssl_ControlCommand_turnOnClockTestMode);
}
